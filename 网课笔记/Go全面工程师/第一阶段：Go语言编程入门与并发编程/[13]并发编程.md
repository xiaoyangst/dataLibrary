## 初体验

使用关键字 `go` 启动 Goroutine 非常简单：

```go
go someFunction()
```

**Goroutine 是 Go 的并发单位**，类似于线程，但比线程更轻量。

每个 Goroutine 初始栈空间非常小（约 **2KB**），并且可以动态增长。

同一程序中可以轻松创建成千上万的 Goroutine，而不会像线程那样占用大量资源。

在 Java 或 C++ 中，创建成千上万个线程会迅速耗尽系统资源，而 Go 可以轻松运行**几十万甚至上百万个** Goroutine。

拓展：[gmp 调度原理](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html)

## 通过 waitgroup 等待协程的执行

| 方法        | 作用                                          |
| ----------- | --------------------------------------------- |
| `wg.Add(n)` | 增加等待计数器 n（通常在启动 goroutine 前）   |
| `wg.Done()` | 将等待计数器减 1（通常在 goroutine 结束时）   |
| `wg.Wait()` | 阻塞，直到计数器归零（即所有 goroutine 完成） |

`Add()` 要在 goroutine 启动前调用，否则可能会引起数据竞争。

`Done()` 通常用 `defer wg.Done()` 放在 goroutine 的开头，确保即使 panic 也能正确减少计数。

`WaitGroup` 本身不能被复制，应以指针形式传递。

```go
func test(index int, wg *sync.WaitGroup) {
	defer wg.Done() // 确保在函数退出时通知WaitGroup已完成
	fmt.Println("cur index" + strconv.Itoa(index))
}

func main() {

	var wg sync.WaitGroup

	for i := 0; i < 10; i++ {
		wg.Add(1)	// 每启动一个 goroutine 前增加计数器
		go test(i, &wg)
	}

	wg.Wait()	// 等待所有goroutine完成
}
```

## 通过mutex和atomic完成全局变量的原子操作

### 使用 sync.Mutex 实现原子操作

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mutex   sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()

    // 关键操作
    mutex.Lock()
    counter++
    mutex.Unlock()
}

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }

    wg.Wait()
    fmt.Println("Final counter value:", counter)
}

```

### 使用 sync/atomic 实现真正的**原子操作**

```gO
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var counter int64 // 必须是 int32 或 int64 类型

func increment(wg *sync.WaitGroup) {
    defer wg.Done()

    atomic.AddInt64(&counter, 1)	// 关键操作
}

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }

    wg.Wait()
    fmt.Println("Final counter value:", counter)
}

```

## RWMutex读写锁

允许多个 **读操作并发执行**，但写操作是**独占的**。

| 操作        | 是否阻塞其他读       | 是否阻塞写       |
| ----------- | -------------------- | ---------------- |
| `RLock()`   | 否                   | 是（会阻塞写）   |
| `Lock()`    | 是                   | 是（会阻塞所有） |
| `RUnlock()` | 是（必须对应 RLock） | 否               |
| `Unlock()`  | 否                   | 否               |

`RLock()` （读锁）和 `Lock()` （写锁）不能混用解锁。调用了 `RLock()`，必须用 `RUnlock()` 释放；同样，`Lock()` 要用 `Unlock()`。

不要忘记用 `defer` 释放锁，避免死锁。

写操作会阻塞所有读写操作，读操作只会阻塞写。

```go
var global_num int = 0

// 写操作（独占锁）
func write(wait *sync.WaitGroup, WLock *sync.RWMutex) {
	defer wait.Done()
	WLock.Lock()
	defer WLock.Unlock()

	time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
	global_num++
	fmt.Println("write: ", global_num)
}

// 读操作（共享锁）
func read(wait *sync.WaitGroup, RLock *sync.RWMutex) {
	defer wait.Done()
	RLock.RLock()
	defer RLock.RUnlock()

	time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
	fmt.Println("read: ", global_num)
}

func main() {
	rand.Seed(time.Now().UnixNano())

	var wait sync.WaitGroup
	var mx sync.RWMutex

	for i := 0; i < 10; i++ {
		wait.Add(1)
		if i%3 == 0 {
			go write(&wait, &mx)
		} else {
			go read(&wait, &mx)
		}
	}

	wait.Wait()
}
```

## 通过 channel 进行 goroutine 之间的通信

`channel` 是 goroutine 安全的通信管道。

一个 goroutine 向 channel 发送数据，另一个 goroutine 从中接收数据。

发送和接收操作会自动同步（除非是带缓冲的 channel）。

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wait sync.WaitGroup
	msg := make(chan string, 1) // 实例化带缓冲 channel

	wait.Add(1)
	go func() {
		defer wait.Done()
		msg <- "hello world" // 发送消息
	}()

	wait.Wait()

	// 在主 goroutine 中接收消息
	revMsg := <-msg
	fmt.Println(revMsg)
}
```

重点先知道如何把消息给到 channel，以及如何从里面读取消息。要注意写和读要在不同的两个 goroutine 中来做。

```go
msg <- "hello world" // 发送消息到指定 channel
revMsg := <-msg		// 从指定 channel 读取 消息
```

## channel 类型

### 无缓冲 channel

```go
ch := make(chan int)
```

**特性**：发送和接收必须同步进行，**发送方会阻塞**直到接收方接收。

**适用场景**：用于 goroutine 之间的强同步。

```go
go func() {
	ch <- 10 // 等待接收方
}()
val := <-ch // 接收值
```

### 有缓冲 channel

```go
ch := make(chan string, 3) // 缓冲大小为 3
```

**特性**：可以缓存最多 3 个元素，发送不会立即阻塞，直到缓冲区满。

**适用场景**：生产者-消费者模型、批处理任务等。

```go
ch <- "a"
ch <- "b"
ch <- "c" // 还不会阻塞
```

### 单向 channel

（1）只发送 channel

```go
func sendOnly(ch chan<- int) {
	ch <- 1
}
```

`chan<- int`：只允许发送，不允许接收。

（2）只接受 channel

```go
func receiveOnly(ch <-chan int) {
	val := <-ch
	fmt.Println(val)
}
```

`<-chan int`：只允许接收，不允许发送。

### nil Channel

```go
var ch chan int // 默认为 nil
```

**特性**：读写操作会永久阻塞。

**适用场景**：用作 `select` 中的动态控制通道。

```go
var ch chan int // nil

select {
case v := <-ch: // 永远不会执行
    fmt.Println(v)
default:
    fmt.Println("default triggered")
}
```

## for range 对 channel 进行遍历

在 Go 中，`for range` 可以用来**遍历 channel 中的所有数据项**，这是接收 channel 数据的一种非常简洁、高效的方式。它会一直从 channel 中接收数据，直到 channel 被 **显式关闭（`close(chan)`）**。

```go
for val := range ch {
    fmt.Println(val)
}
```

`val` 是从 `ch` 中接收到的值。这个循环会 **阻塞** 等待 channel 中的数据。**当 channel 被关闭且数据被读完，循环才会退出**。

如何想让循环不再继续，可以显示调用 close(chan)。这是因为`for range` **必须依赖 channel 的关闭信号来结束循环**。如果你没有 `close(ch)`，`for range` 会一直阻塞等待新数据，最终导致 **死锁** 或 **goroutine 卡住**。

**如果 channel 已经被关闭，那么就不允许往里面放值，但是还可以取值。**

## 监控 goroutine 的执行





