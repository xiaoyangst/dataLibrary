[TOC]



# 讲一讲策略模式

策略模式能让你定义一系列算法，并将每种算法分别封装起来，使它们**可以相互替换**。

就比方说我们要实现不同的排序算法，抽象基类的定义一个纯虚函数 Sort，那么不同派生类重写抽象基类的 Sort 方法来代表不同的排序算法。使用者只需要通过替换不同的算法对象就可以调用相同接口的情况下使用不同的排序算法。

![img](images/1747572034830-1.png)

# 讲一讲代理模式

代理对象允许你**通过创建一个代理对象来控制对另一个对象（即目标对象）的访问（代理对象和目标对象继承同一个基类）**。代理对象充当了目标对象的接口，客户端通过代理对象来间接访问目标对象，而不是直接访问。

代理模式还是很常见的，目标对象进行核心功能的实现，而不必关系那些细枝末节，而是把这些细枝末节交由代理对象完成，再由代理对象调用目标对象提供的接口。

比方说，目标对象提供 splitWord 的接口，但是它不会对即将分词的字符串进行预处理，而是假设字符串都是合乎规范的。此刻， 代理对象就起到作用了，代理对象实现 splitWord 的接口只需要完成两步骤：预处理字符串合符规范，调用目标对象的 splitWord 的接口。预处理字符串合符规范是对外界访问的一种控制，如果这个字符串不合法，代理可以选择拒绝访问实际提供服务的对象，或者选择将不合法的字符串进行修正再去访问实际提供服务者，这取决于个人的实现。可见，**代理模式不是在被代理的对象上新增功能，而是控制对被代理对象的访问**。

说到代理就容易想到 Nginx，用户发送的网络请求先通过 Nginx **一番处理**之后再把网络请求转发给后端服务器。至于一番处理究竟是什么完全看应用场景，可以拦截限制的用户，也可以选择负载均衡到相应的服务器。总的来讲，**代理模式就是在实际提供服务的一方设置一堵墙**，让实际提供服务者的访问得到限制。那么，不就把代理实现和底层功能实现给分离出来了吗？可以让不同的开发者开发各自的功能，且互不影响。

![img](images/1747572039667-4.png)

# 讲一讲模板方法模式

模板方法模式定义了一个算法的骨架，把某些步骤的具体实现推迟到子类中完成。骨架中的步骤，共用的方法可以由父类具体实现，其余的方法就由子类自行实现。

比如制作一杯咖啡：先烧水 --> 冲泡咖啡 --> 倒进杯子 --> 加糖或奶。

不管是制作一杯怎样的咖啡，上面的流程是固定的（模板），但是具体的细节可能有所变动：

![img](images/1747572043403-7.png)

# 讲一讲外观模式

**外观模式**为子系统中的一组接口提供一个**统一的高层接口**，使得子系统更容易使用。

我们在开发程序的时候，通常设计有日志系统，配置文件，连接池，网络服务。服务启动之初需要对这些模块进行初始化以及服务结束之后的回收操作。为了方便用户的使用，我们选择新建一个类，把这些模块的全部初始化操作放在一个简单的接口，回收操作放在一个简单接口中。使用者无需关心这些负责模块的创建和回收， 只需要调用已封装好的接口即可，非常方便。

![img](images/1747572049022-10.png)

**注**：不存在抽象基类和派生类重写的说法，是**一个**具体的类来把所有对象创建并把复杂的接口封装为一个简单接口

```c++
#include <iostream>

class DVDPlayer {
public:
    void on() { std::cout << "DVD Player ON\n"; }
    void play() { std::cout << "Playing movie...\n"; }
    void off() { std::cout << "DVD Player OFF\n"; }
};

class Projector {
public:
    void on() { std::cout << "Projector ON\n"; }
    void wideScreenMode() { std::cout << "Projector in widescreen mode\n"; }
    void off() { std::cout << "Projector OFF\n"; }
};

class Amplifier {
public:
    void on() { std::cout << "Amplifier ON\n"; }
    void setVolume(int level) { std::cout << "Volume set to " << level << "\n"; }
    void off() { std::cout << "Amplifier OFF\n"; }
};

class Lights {
public:
    void dim(int level) { std::cout << "Lights dimmed to " << level << "%\n"; }
};

// 没有抽象类，也没有重写等说法，只有一个纯粹的类
class HomeTheaterFacade {
private:    // 实例化全部功能的对象
    DVDPlayer* dvd;
    Projector* projector;
    Amplifier* amp;
    Lights* lights;

public:
    HomeTheaterFacade(DVDPlayer* d, Projector* p, Amplifier* a, Lights* l)
        : dvd(d), projector(p), amp(a), lights(l) {}

    void watchMovie() {
        std::cout << "--- Get ready to watch a movie ---\n";
        lights->dim(10);
        projector->on();
        projector->wideScreenMode();
        amp->on();
        amp->setVolume(5);
        dvd->on();
        dvd->play();
    }

    void endMovie() {
        std::cout << "--- Shutting down movie theater ---\n";
        dvd->off();
        amp->off();
        projector->off();
    }
};

int main() {
    DVDPlayer dvd;
    Projector projector;
    Amplifier amp;
    Lights lights;

    HomeTheaterFacade homeTheater(&dvd, &projector, &amp, &lights);
    homeTheater.watchMovie();
    std::cout << "\n";
    homeTheater.endMovie();
}
```

# 讲一讲状态模式

状态模式可以让物件在其内部状态有变化时，改为其行为。这种模式有点像有限状态机的概念。状态模式可以被当成一种策略模式，它能够在调用模式界面中所定义的方法来切换策略。

计算机编程中，状态模式用于，当同一物件基于其内部状态而有不同行为，将其行为进行封装。

![img](images/1747572055368-13.png)

# 讲一讲观察者模式

用于建立对象之间的**一对多依赖关系**，当一个对象状态发生改变时，其所有依赖者（观察者）都会自动收到通知并更新。

首先创建一个主题，以及多个观察者，这些观察者注册这个主题（相当于加入到主题中，主题记录这些观察者），等到主题更新消息的时候，这些消息就会逐一发给记录的观察者。当然，也是提供取消注册功能的，这样以后主题更新消息它也不会收到了。

![img](images/1747572061441-16.png)

所谓一对多，指的就是一个主题对应多个不同的观察者。

```c++
#include <iostream>
#include <vector>
#include <memory>

// 抽象观察者
class Observer {
public:
    virtual void update(const std::string& msg) = 0;
    virtual ~Observer() = default;
};

// 被观察者（主题）
class Subject {
private:
    std::vector<std::shared_ptr<Observer>> observers;

public:
    void attach(std::shared_ptr<Observer> obs) {
        observers.push_back(obs);
    }

    void notify(const std::string& msg) {
        for (auto& obs : observers) {
            obs->update(msg);
        }
    }
};

// 具体观察者 A
class EmailSubscriber : public Observer {
public:
    void update(const std::string& msg) override {
        std::cout << "[邮件] 收到通知：" << msg << "\n";
    }
};

// 具体观察者 B
class SMSSubscriber : public Observer {
public:
    void update(const std::string& msg) override {
        std::cout << "[短信] 收到通知：" << msg << "\n";
    }
};

// 使用
int main() {
    Subject topic;
    topic.attach(std::make_shared<EmailSubscriber>());
    topic.attach(std::make_shared<SMSSubscriber>());

    topic.notify("你关注的订单已发货！");
}
```

主题可以理解为数据的源头，而观察者是关心这些数据的实例，数据生成之后是转发给观察者集合，主题不与真正的用户见面，而是由观察者自行处理。比方说代码中接收到的消息，转发给不同的观察者（邮件观察者和短信观察者），即对应不同的服务平台（邮件平台和短信平台），对这些消息的加工处理就是观察者的事情，主题就不关系了。

可以看出，代码中只有一个具体的主题，并没有实现主题的抽象，来生成不同的主题。这并不难实现，只需要把主题抽象出一个基类即可，这依旧不影响观察者模式是一对多的模式，即一个主题管理多个观察者。

<img src="images/1747572069150-19.png" alt="img" style="zoom:50%;" />

# 讲一讲工厂模式

## 简单工厂

简单工厂是一个具体的工厂和一个产品抽象类，通过用户传入的参数来通过工厂生成不同的实例对象：

```c++
#include <iostream>
#include <memory>
#include <string>

// 抽象产品
class Product {
public:
    virtual void use() = 0;
    virtual ~Product() = default;
};

// 具体产品A
class ProductA : public Product {
public:
    void use() override {
        std::cout << "使用产品 A\n";
    }
};

// 具体产品B
class ProductB : public Product {
public:
    void use() override {
        std::cout << "使用产品 B\n";
    }
};

// 工厂类
class SimpleFactory {
public:
    static std::shared_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_shared<ProductA>();
        } else if (type == "B") {
            return std::make_shared<ProductB>();
        } else {
            return nullptr;
        }
    }
};

int main() {
    auto p1 = SimpleFactory::createProduct("A");
    auto p2 = SimpleFactory::createProduct("B");

    if (p1) p1->use();
    if (p2) p2->use();
}
```

## 工厂方法

简单工厂是一个具体的工厂和一个产品抽象类，而工厂方法是一个抽象的工厂和一个产品抽象类。

之前的简单工厂生产很杂，分工不明确，一个工厂可能既生产手机，也生产空调。

但是工厂方法把任务划分清楚，一个具体的工厂生产一个产品，因此工厂和产品都有抽象的基类。比如手机工厂生产小米手机，空调工厂生产小米空调。

```c++
#include <iostream>
#include <memory>

// 抽象产品
class Product {
public:
    virtual void use() = 0;
    virtual ~Product() = default;
};

// 具体产品 A
class ProductA : public Product {
public:
    void use() override {
        std::cout << "使用产品 A\n";
    }
};

// 具体产品 B
class ProductB : public Product {
public:
    void use() override {
        std::cout << "使用产品 B\n";
    }
};

// 抽象工厂
class Factory {
public:
    virtual std::shared_ptr<Product> createProduct() = 0;
    virtual ~Factory() = default;
};

// 具体工厂 A
class FactoryA : public Factory {
public:
    std::shared_ptr<Product> createProduct() override {
        return std::make_shared<ProductA>();
    }
};

// 具体工厂 B
class FactoryB : public Factory {
public:
    std::shared_ptr<Product> createProduct() override {
        return std::make_shared<ProductB>();
    }
};

int main() {
    std::unique_ptr<Factory> factoryA = std::make_unique<FactoryA>();
    auto productA = factoryA->createProduct();
    productA->use();

    std::unique_ptr<Factory> factoryB = std::make_unique<FactoryB>();
    auto productB = factoryB->createProduct();
    productB->use();
}
```

## 抽象工厂

抽象工厂是一个具体的工厂生产一系列的同类产品，因此工厂和产品都有抽象的基类。比如手机产品抽象基类对应小米手机和华为手机具体类，空调工厂抽象基类对应小米空调和华为空调具体类。工厂抽象基类对应小米工厂和华为工厂具体类，小米工厂生产小米手机和小米空调，华为工厂生产华为手机和华为空调。

![img](https://gsavaex3vh.feishu.cn/space/api/box/stream/download/asynccode/?code=YmNlMWQwNDk3MDkyMTYyNWI4YTBmODkyOWE0NjFhZmFfZGZ0WTRDSjY5cjI3eGpVS2dJM2o2ZnRhbWg1Wm5LdE1fVG9rZW46RklmYWJubVFmb0R4aUJ4QWtodWNrZWxZbkRkXzE3NDc1NzIwMDI6MTc0NzU3NTYwMl9WNA)

注：如果一个工厂只生产一种产品，抽象工厂就退化为工厂方法。

# 讲一讲单例模式

- 希望整个系统中只有这一个类的实例
- 创建一个实例非常耗时，只希望创建一次

```c++
#include <iostream>
#include <mutex>

class Singleton {
private:
    Singleton() {
        std::cout << "构造 Singleton\n";
    }

    ~Singleton() = default;

    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    static Singleton& getInstance() {
        static Singleton instance;  // C++11起线程安全
        return instance;
    }

    void doSomething() {
        std::cout << "调用 doSomething()\n";
    }
};

int main() {
    Singleton::getInstance().doSomething();
}
```

# 讲一讲访问者模式

# 讲一讲备忘录模式

# 讲一讲迭代器模式

# 讲一讲命令模式

# 讲一讲责任链模式

# 讲一讲享元模式

# 讲一讲装饰模式

装饰模式也可以称之为封装模式，所谓的封装就是在原有行为之上进行拓展，并不会改变该行为。

这就特别容易和代理模式弄混，两者的区别在于代理模式控制对对象的访问，装饰模式扩展对象的功能：

- 装饰模式的目的是：动态地为对象添加额外功能，不改变其接口。强调的是“增强功能”。
- 代理模式的目的是：为另一个对象提供一个替代或占位符，以控制对它的访问。强调的是“控制访问”。

```c++
#include <iostream>
#include <memory>

// 抽象组件
class Component {
public:
    virtual void draw() = 0;
    virtual ~Component() = default;
};

// 具体组件
class TextView : public Component {
public:
    void draw() override {
        std::cout << "Drawing TextView";
    }
};

// 装饰器基类
class Decorator : public Component {
protected:
    std::shared_ptr<Component> component;
public:
    Decorator(std::shared_ptr<Component> comp) : component(std::move(comp)) {}
};

// 具体装饰器1：添加边框
class BorderDecorator : public Decorator {
public:
    BorderDecorator(std::shared_ptr<Component> comp) : Decorator(std::move(comp)) {}

    void draw() override {
        component->draw();
        std::cout << " with Border";
    }
};

// 具体装饰器2：添加滚动条
class ScrollDecorator : public Decorator {
public:
    ScrollDecorator(std::shared_ptr<Component> comp) : Decorator(std::move(comp)) {}

    void draw() override {
        component->draw();
        std::cout << " with Scroll";
    }
};

// 示例用法
int main() {
    std::shared_ptr<Component> textView = std::make_shared<TextView>();	// 基础功能
    // 基于基础功能添加两个额外功能
    // 每新增一个功能就会返回一个对象，把这个新对象继续传递才可以把之前添加的功能保留，然后继续往下添加新功能
    std::shared_ptr<Component> borderedTextView = std::make_shared<BorderDecorator>(textView);
    std::shared_ptr<Component> fullyDecorated = std::make_shared<ScrollDecorator>(borderedTextView);

    fullyDecorated->draw();  // 输出: Drawing TextView with Border with Scroll
    return 0;
}
```



# 讲一讲桥接模式



# 讲一讲适配器模式



# 讲一讲原型模式



# 讲一讲建造者模式



# 拓展：模板方法引出的钩子函数

**钩子函数**是**在模板方法中调用的“可选”方法**，它们通常：

- 在基类中提供一个**空实现**或默认实现
- 子类**可以选择**是否重写它
- 不会影响算法的主流程，但可以“插入”定制行为

```c++
#include <iostream>

class CaffeineBeverageWithHook {
public:
    void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {  // 钩子函数控制流程
            addCondiments();
        }
    }

    virtual ~CaffeineBeverageWithHook() = default;

protected:
    void boilWater() {
        std::cout << "Boiling water\n";
    }

    void pourInCup() {
        std::cout << "Pouring into cup\n";
    }

    virtual void brew() = 0;
    virtual void addCondiments() = 0;

    // 钩子：默认返回 true，可由子类覆盖
    virtual bool customerWantsCondiments() {
        return true;
    }
};

class TeaWithHook : public CaffeineBeverageWithHook {
protected:
    void brew() override {
        std::cout << "Steeping the tea\n";
    }

    void addCondiments() override {
        std::cout << "Adding Lemon\n";
    }

    bool customerWantsCondiments() override {
        char answer;
        std::cout << "Would you like lemon with your tea (y/n)? ";
        std::cin >> answer;
        return answer == 'y' || answer == 'Y';
    }
};

int main() {
    TeaWithHook tea;
    tea.prepareRecipe();
    return 0;
}
```

# 拓展：观察者模式+状态模式配合

# 拓展：观察者模式和发布订阅模式的区别