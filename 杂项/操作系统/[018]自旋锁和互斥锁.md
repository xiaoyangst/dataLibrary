### **自旋锁（Spin Lock）**

- **工作原理**：线程尝试获取锁时，如果锁已被占用，则**持续循环检查锁的状态**（即 “自旋”），直到锁被释放。
- 特点：
  - **不释放 CPU**：线程会一直占用 CPU 资源进行忙等待，因此适用于锁持有时间很短的场景。
  - **低开销**：避免了线程上下文切换的开销（内核态与用户态的切换）。
  - **可能导致 CPU 浪费**：如果锁的持有时间较长，自旋会浪费大量 CPU 资源。
- **适用场景**：锁竞争不激烈、临界区执行时间极短的场景（如内核代码中的短期操作）。

### **互斥锁（Mutex）**

- **工作原理**：线程尝试获取锁时，如果锁已被占用，则**线程会被挂起（进入睡眠状态）**，直到锁被释放后由操作系统唤醒。
- 特点：
  - **释放 CPU**：线程挂起时不占用 CPU 资源，适合锁持有时间较长的场景。
  - **高开销**：线程上下文切换（从用户态到内核态）的成本较高。
  - **避免 CPU 浪费**：锁被持有时，其他线程不会空转。
- **适用场景**：锁竞争激烈、临界区执行时间较长的场景（如 I/O 操作、数据库访问）。